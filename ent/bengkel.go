// Code generated by entc, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"

	"github.com/facebookincubator/ent/dialect/sql"
)

// Bengkel is the model entity for the Bengkel schema.
type Bengkel struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// KodeBengkel holds the value of the "kode_bengkel" field.
	KodeBengkel string `json:"kode_bengkel,omitempty"`
	// NamaBengkel holds the value of the "nama_bengkel" field.
	NamaBengkel string `json:"nama_bengkel,omitempty"`
	// AlamatBengkel holds the value of the "alamat_bengkel" field.
	AlamatBengkel string `json:"alamat_bengkel,omitempty"`
	// Latitude holds the value of the "latitude" field.
	Latitude float64 `json:"latitude,omitempty"`
	// Longitude holds the value of the "longitude" field.
	Longitude float64 `json:"longitude,omitempty"`
	// Phonenumber holds the value of the "phonenumber" field.
	Phonenumber string `json:"phonenumber,omitempty"`
}

// FromRows scans the sql response data into Bengkel.
func (b *Bengkel) FromRows(rows *sql.Rows) error {
	var scanb struct {
		ID            int
		KodeBengkel   sql.NullString
		NamaBengkel   sql.NullString
		AlamatBengkel sql.NullString
		Latitude      sql.NullFloat64
		Longitude     sql.NullFloat64
		Phonenumber   sql.NullString
	}
	// the order here should be the same as in the `bengkel.Columns`.
	if err := rows.Scan(
		&scanb.ID,
		&scanb.KodeBengkel,
		&scanb.NamaBengkel,
		&scanb.AlamatBengkel,
		&scanb.Latitude,
		&scanb.Longitude,
		&scanb.Phonenumber,
	); err != nil {
		return err
	}
	b.ID = scanb.ID
	b.KodeBengkel = scanb.KodeBengkel.String
	b.NamaBengkel = scanb.NamaBengkel.String
	b.AlamatBengkel = scanb.AlamatBengkel.String
	b.Latitude = scanb.Latitude.Float64
	b.Longitude = scanb.Longitude.Float64
	b.Phonenumber = scanb.Phonenumber.String
	return nil
}

// Update returns a builder for updating this Bengkel.
// Note that, you need to call Bengkel.Unwrap() before calling this method, if this Bengkel
// was returned from a transaction, and the transaction was committed or rolled back.
func (b *Bengkel) Update() *BengkelUpdateOne {
	return (&BengkelClient{b.config}).UpdateOne(b)
}

// Unwrap unwraps the entity that was returned from a transaction after it was closed,
// so that all next queries will be executed through the driver which created the transaction.
func (b *Bengkel) Unwrap() *Bengkel {
	tx, ok := b.config.driver.(*txDriver)
	if !ok {
		panic("ent: Bengkel is not a transactional entity")
	}
	b.config.driver = tx.drv
	return b
}

// String implements the fmt.Stringer.
func (b *Bengkel) String() string {
	var builder strings.Builder
	builder.WriteString("Bengkel(")
	builder.WriteString(fmt.Sprintf("id=%v", b.ID))
	builder.WriteString(", kode_bengkel=")
	builder.WriteString(b.KodeBengkel)
	builder.WriteString(", nama_bengkel=")
	builder.WriteString(b.NamaBengkel)
	builder.WriteString(", alamat_bengkel=")
	builder.WriteString(b.AlamatBengkel)
	builder.WriteString(", latitude=")
	builder.WriteString(fmt.Sprintf("%v", b.Latitude))
	builder.WriteString(", longitude=")
	builder.WriteString(fmt.Sprintf("%v", b.Longitude))
	builder.WriteString(", phonenumber=")
	builder.WriteString(b.Phonenumber)
	builder.WriteByte(')')
	return builder.String()
}

// Bengkels is a parsable slice of Bengkel.
type Bengkels []*Bengkel

// FromRows scans the sql response data into Bengkels.
func (b *Bengkels) FromRows(rows *sql.Rows) error {
	for rows.Next() {
		scanb := &Bengkel{}
		if err := scanb.FromRows(rows); err != nil {
			return err
		}
		*b = append(*b, scanb)
	}
	return nil
}

func (b Bengkels) config(cfg config) {
	for _i := range b {
		b[_i].config = cfg
	}
}
